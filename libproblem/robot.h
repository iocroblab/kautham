/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 


#if !defined(_ROBOT_H)
#define _ROBOT_H


#include "obstacle.h"
#include "link.h"
#include <mt/transform.h>
#include <libsampling/robconf.h>
//#include <Inventor/VRMLnodes/SoVRMLExtrusion.h>
#include "inversekinematic.h"
#include "constrainedkinematic.h"
#include <list>


using namespace std;
	
//class InverseKinematic;

namespace libProblem {
  struct attObj{
    attObj(){obs=NULL; link=NULL;}
    ~attObj(){obs=NULL; link=NULL;}
    Obstacle*     obs;
    Link*         link;
    mt::Transform trans;
    bool toLink( string linkName ){
      return link->getName() == linkName;
    }
  };

  class Robot {
  public:
    Robot(string robFile, KthReal scale, LIBUSED lib = IVPQP);

	  Link* getLink(unsigned int i);
    Link* getLinkByName( string linkName );

	  bool autocollision(int t=0);

    //! This method builds the link model and all their data structures in order
    //! to keep the coherence in the robot assembly. It doesn't use any intermediate
    //! structure to adquire the information to do the job.
    bool addLink(string name, string ivFile, KthReal theta, KthReal d, KthReal a,
                 KthReal alpha, bool rotational, bool movable, KthReal low,
                 KthReal hi, KthReal w, string parentName, KthReal preTrans[] = NULL);

//    //! This method is deprecated because It uses the DATA intermediate structure.
//    //! Please don't use it and take care with your Rob file to define the robot correctly.
//	  bool addLink(string name, string ivFile, KthReal theta, KthReal d, KthReal a,
//                 KthReal alpha, bool rotational, bool movable, KthReal low,
//                 KthReal hi,  KthReal w, string parentName, DATA *preTrans = NULL);
  	
	  //!	This member function set the robot name.
	  inline void setName(string nam){name = nam;}

    inline string getName() const {return name;}

    //! It sets the robot to the pose bring by the robq parameter.
    bool Kinematics(RobConf *robq);

    bool Kinematics(RobConf& robq);

    bool Kinematics(SE3Conf& q) ;

    bool Kinematics(RnConf& q);

    //!	This method uses the Configuration q to set up the position, orientation,
    //!	and articular values if the robot has one. If the configuration q is SE2 or SE3
    //!	the robot change the position and/or orientation either the configuration is
    //!	Rn the robot change the articular values.
	  bool Kinematics(Conf *q);

    // This member method is the interface to calling the inverse kinematic
    //   object associated. It returns the RobConf<SE3Conf,RnConf> configuration
    //   that describe the pose of the robot completely.
    //
    RobConf& InverseKinematics(vector<KthReal> &target);
	
    /** This member method is another interface to calling the inverse kinematic
      *   object associated. It returns the RobConf<SE3Conf,RnConf> configuration
      *   that describe the pose of the robot completely.
      */
    RobConf& InverseKinematics(vector<KthReal> &target, vector<KthReal> masterconf,
                               bool maintainSameWrist);

    void setHomePos(Conf* qh);

    void setInitPos(Conf *qi);

	  void setGoalPos(Conf *qg);

    //! This method returns the current RobConf used to
    //! represent the SE3 position and Rn configuration
    inline RobConf* getCurrentPos(){return &_currentConf;}

    inline RobConf* getInialPos(){ return &_initConf;}

    inline RobConf* getGoalPos(){ return &_goalConf;}

    inline RobConf* getHomePos(){ return &_homeConf;}

	  bool collisionCheck(Obstacle *obs);

    bool collisionCheck(Robot *rob);

	  KthReal distanceCheck(Obstacle *obs, bool min = true);

    KthReal distanceCheck(Robot *rob, bool min = true);

	  bool setLimits(int member, KthReal min, KthReal max);

    void* getModel();

    void* getModelFromColl();

    //! This method makes the mapping between control values and configurations.
    //! The method receives the values and it makes the changes in respective configurations 
    //! If the robot is freeflying only changes the SE3/SE2 Conf corresponding to 
    //! position and orientation of it using the Kinematics methods, but if the robot 
    //! is a chain or a tree robot, this method changes a SE3/SE2 Conf (position 
    //! and orientation) and a Rn Conf for articular values. All values are between 0 and 1.
    void control2Pose(vector<KthReal> &values);

    //! This method maps the values of position/pose of robot taking into account the movement
    //! limits.  
    Conf& parameter2Conf(vector<KthReal> &values, CONFIGTYPE type);

    //! This method returns the type of libraries used to build the models.
    inline LIBUSED whatLibs(){return libs;}

	  inline KthReal* getLimits(int member){return _spatialLimits[member];}
  	
	  //!	This member function returns the robot type.
	  //!	This member function returns the robot type, in this case it returns a 
	  //	FREEFLY constant. For compatibility with other robot types. 
	  inline ROBOTTYPE getRobotType(){return robType;}

	  //!	This member funcion set a robot type.
	  //!	This member funcion set a robot type, in this case is FREEFLY constant 
	  //		For compatibility with other type of robots.
	  inline void setRobotType(ROBOTTYPE rob){robType = rob;}

	  //!	This member funcion return a problem type.
	  //!	This member funcion return a problem type. For freefling robots, it can
	  //	be SE2, SE3, R2 or R3. 
	  //inline CONFIGTYPE getProblemType(){return probType;}

	  //!	This member funcion set a problem type.
	  //!	This member funcion set a problem type.  For freefling robots, it can
	  //	be SE2, SE3, R2 or R3. 
	  //inline void setProblemType(CONFIGTYPE pT){probType = pT;}

    inline KthReal getScale() const {return scale;}


	
    inline int getTrunk() const {return nTrunk;}

    inline KthReal* getWeightSE3(){
      KthReal tmp=1.;
      if( _weights != NULL ) 
        return _weights->getSE3Weight(); 
      else 
        throw exception();
    }

    inline vector<KthReal>& getWeightRn(){
      if( _weights != NULL ) 
        return _weights->getRnWeights();
      else
        throw exception();
    }

    RobWeight* getRobWeight(){return _weights;}
    
    inline void setDHApproach(DHAPPROACH dhA){dhApproach = dhA;}

    inline DHAPPROACH getDHApproach(){return dhApproach;}

    //!	This fuction return the joint number that compose the Robot. 
    inline unsigned int getNumJoints(){return ((unsigned int)links.size()) - 1;}

    //!	This fuction return the link number that compose the Robot. 
    inline unsigned int getNumLinks(){return (unsigned int)links.size();}

    void parameter2Pose(vector<KthReal> &values);

    void control2Parameters(vector<KthReal> &control, vector<KthReal> &parameters);

    inline bool isSE3Enabled() const {return se3Enabled;}
    bool setInverseKinematic(INVKINECLASSES type);
    bool setInverseKinematicParameter(string name, KthReal value);
	  InverseKinematic* getIkine(){return _ikine;}
    
    // \brief This method defines the control and the offset matrixes.
    //   Keep in mind that the control are values between [-0.5,0.5]
    //   meanwhile the normalized configuration are values between
    //   [0, 1] for this reason in the SE3 freeflying robots the offset
    //   matrix should be forced to be 0.5.
    
    //void setControls(xml_document &doc = xml_document);

    bool setControlItem(string control, string dof, KthReal value);

    inline string getControlsName() const {return controlsName;}
    string getDOFNames();

    inline int getNumControls(){if( armed ) return numControls; return -1;}

    inline mt::Transform& getLastLinkTransform(){ return
                                    *(((Link*)links.at(links.size()-1))->getTransformation());}

    inline mt::Transform& getLinkTransform(unsigned int numLink){
                                    if(numLink<0 || numLink>=links.size()) numLink = links.size()-1;
                                    return
                                        *(((Link*)links.at(numLink))->getTransformation());}

    inline mt::Transform& getHomeTransform(){return *(links[0]->getTransformation());}
    bool                  setProposedSolution(vector<mt::Point3>& pathSE3);
    bool                  setProposedSolution(vector<RobConf*>& path);
    bool                  cleanProposedSolution();

    //! This method returns the Proposed Solution as a vector of RobConf that may be used to guide 
    //! the user.
    inline vector<RobConf>& getProposedSolution(){return _proposedSolution;}
    inline void           setLinkPathDrawn(int n){_linkPathDrawn = n;}
    bool                  setConstrainedKinematic(CONSTRAINEDKINEMATICS type);  
    bool                  setConstrainedKinematicParameter(string name, KthReal value);
	  ConstrainedKinematic* getCkine(){return _constrainKin;}
    RobConf&              ConstrainedKinematics(vector<KthReal> &target);
    bool                  setPathVisibility(bool visible);

    //! This method attaches an existing obstacle to the link specified by the linkName parameter.
    //! This method
    bool                  attachObject(Obstacle* obs, string linkName );

    //! This method moves the attached object to the robot. The object can be attached to any link
    //! of the robot. This method processes the _attachedObj list to calculated the new position and 
    //! orientation based on the position and orientation of the robot link where the object is attached 
    //! and the mt::Transform calculated on the attached instant.
    void                  moveAttachedObj();

    //! This method detaches the previously attached objects to the link named linkName.
    bool                  detachObject( string linkName );

    //! This method returns the maximum value of the D_H parameters. It is used to have an idea about the 
    //! dimension of the links.
    KthReal               maxDHParameter();

  private:
    //! This method updates the absolute position and orientation of each link in the robot.
    void              updateRobot();

    //! This method recalculates the limits in the home frame to be used in the de-normalization
    //! of the mapping between the controls and the absolute SE3 position.
    void              recalculateHomeLimits();

    //! This method denormalizes the SE3 unit representation and returns the positon and the
    //! rotation (quaternion) in a single vector.
    vector<KthReal>   deNormalizeSE3(vector<KthReal> &values);

    //void              setRobotWeights(RobotParse *parser);


    float             diagLimits();

    ROBOTTYPE         robType;
    LIBUSED           libs;

    RobConf           _homeConf;     //!< This attribute is the Home configuration of the robot.
    RobConf           _initConf;     //!< This attribute is the initial configuration of the robot planning problem.
    RobConf           _goalConf;     //!< This attribute is the goal configuration of the robot planning problem.
    RobConf           _currentConf;  //!< This attribute is the current configuration of the robot.

	  KthReal           _spatialLimits[7][2];
    KthReal           _homeLimits[7][2];
  	
	  //!	This Vector contains pointers to each Link
    /*!	This method begins with the Link base and it ends with the location of final effector.
     *  In case of Tree robots, each branch is inserted sequentially
    */
    vector<Link*>     links;

    //!	This attribute show if the Robot is complete or still is under construction.
    bool              armed;

    //!	It is a descriptive name of robot
    string            name;

    //! This is the global scale for all the links that compound the robot.
    //! Normally it is equal to one.
    KthReal scale;

    DHAPPROACH        dhApproach;//! It identifies the D-H description method (Standar/Modified).

    //! This attribute is true if the robot is not freeflying and it could be moved.
    bool              se3Enabled;

    //! weight between translational and rotational components in distance computations
    //KthReal           _weightSE3;
    RobWeight*        _weights;
  	
    //! This is the transformation used to calculate the spatial limits into the home
    //! frame in order to preserve the home ubication at time zero.
    mt::Transform     _homeTrans; //!< This is the Home Reference frame at time zero.

    void*             visModel;
    KthReal           *offMatrix;
    KthReal           **mapMatrix;
    string            controlsName;
    int               numControls;  //!> This is the number of control used to command the robot
    bool              _autocoll;
    bool              _hasChanged;
    int               nTrunk; //!> Number of control for the trunk in case of TREE robot
    InverseKinematic* _ikine;
    ConstrainedKinematic* _constrainKin;
    vector<RobConf>   _proposedSolution;
    SoMFVec3f*        _graphicalPath; //!> This corresponds to translational part of the last link absolute path.
    SoSeparator*      _pathSeparator;
    int               _linkPathDrawn; //!> This is the number of the link whose path will be drawn
    list<attObj>      _attachedObject;
  };
}

#endif  //_ROBOT_H

