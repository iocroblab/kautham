/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

#include "robot.h"
#include "ivsolidelement.h"
#include <libkthutil/kauthamdefs.h>
#include <libkin/inversekinematic.h>
#include <libkin/ivkintx90.h>
#include <libkin/ivkintxhand.h>
#include <libkin/ivkinhand.h>
#include <libkin/ivkin2drr.h>
#include <libkin/constrainedkinematic.h>
#include <mt/point3.h>
#include <mt/rotation.h>
#include <cstdlib>
#include <cstdio>
#include <fstream>
#include <string>
#include <libpugixml/pugixml.hpp>
#include <Inventor/VRMLnodes/SoVRMLExtrusion.h>

#if defined(KAUTHAM_USE_GUIBRO)
#include <libguibro/consbronchoscopykin.h>
#endif


using namespace std;
using namespace Kautham;
using namespace pugi;

namespace libProblem {
  Robot::Robot(string robFile, KthReal scale, LIBUSED lib) {	
	  _linkPathDrawn = -1;
      numCoupledControls=0;
    nTrunk = 0;
    libs = lib;
    this->scale=scale;
    this->armed=false;
    se3Enabled = false;
    _autocoll = false;
    _hasChanged = false;
    numControls = 0;
    // Inialization of SE3 configurations.
    _homeConf.setSE3();
    _initConf.setSE3();
    _goalConf.setSE3();
    _currentConf.setSE3();
    _ikine = NULL;
    _constrainKin = NULL;
    _weights = NULL;
	  visModel = NULL;
	  _graphicalPath = NULL;
	  for(int i =0; i<7;i++)
	    for(int j=0; j<2; j++){
	      _homeLimits[i][j] = 0.;
		  _spatialLimits[i][j] = 0.;
	  }
    const KthReal toRad = M_PI/180.;

    //  if the file has rob extension it will be parsed in order to 
    //  create the links, otherwise there are create the base "Link"
    //  as a freefly.
    fstream fin;
    fin.open(robFile.c_str(),ios::in);
    if( fin.is_open() ){ // The file already exists.
      fin.close();
      string::size_type loc = robFile.find( ".rob", 0 );
      string dir;
      if( loc != string::npos ) { // It means that the robot is a kinematic chain.
        dir = robFile.substr(0,robFile.find_last_of("/")+1);

        // Opening the file with the new pugiXML library.
        xml_document doc;
        xml_parse_result result = doc.load_file(robFile.c_str());

        string tmpString = "";
        if(result){
          //  Once the file has been parsed, it contains the links information
          //  and now the links could be constructed.

          name = doc.child("Robot").attribute("name").value();

          tmpString = doc.child("Robot").attribute("DHType").value();
          if( tmpString == "Standard")
            dhApproach = DHSTANDARD;
          else
            dhApproach = DHMODIFIED;

          tmpString = doc.child("Robot").attribute("robType").value();
          if( tmpString == "Tree")
            robType = TREE;
          else
            robType = CHAIN;

          int numLinks = doc.child("Robot").child("Joints").attribute("size").as_int();

          _weights = new RobWeight( numLinks - 1 );

          if( doc.child("Robot").child("WeightSE3") ){
            KthReal tra = 1.;
            KthReal rot = 1.;
            xml_node tmp = doc.child("Robot").child("WeightSE3");
            if( tmp.attribute("rho_t") )
              tra = (KthReal) tmp.attribute("rho_t").as_double();
            if( tmp.attribute("rho_r") )
              rot = (KthReal) tmp.attribute("rho_r").as_double();
            _weights->setSE3Weight( tra, rot );

          }else
            _weights->setSE3Weight(1., 1.);


          // Initialization of the RnConf part of the RobConf for each
          // special poses, the initial, the goal, the Home and the current poses.
          
          _homeConf.setRn( numLinks - 1 );
          _currentConf.setRn( numLinks - 1 );
          _initConf.setRn( numLinks - 1 );
          _goalConf.setRn( numLinks - 1 );

          xml_node linkNode = doc.child("Robot").child("Joints");
          KthReal* preTransP = NULL;
          KthReal preTrans[7]= {0., 0., 0., 0., 0., 0., 0.};
          int i = 0;
          KthReal limMin, limMax;
          limMin = limMax = 0.;
          for(xml_node_iterator it = linkNode.begin(); it != linkNode.end(); ++it){
            xml_node preTNode = (*it).child("PreTrans");
            if( preTNode != NULL ){
              preTransP = preTrans;
              preTrans[0] = (KthReal)preTNode.attribute("X").as_double();
              preTrans[1] = (KthReal)preTNode.attribute("Y").as_double();
              preTrans[2] = (KthReal)preTNode.attribute("Z").as_double();
              preTrans[3] = (KthReal)preTNode.attribute("WX").as_double();
              preTrans[4] = (KthReal)preTNode.attribute("WY").as_double();
              preTrans[5] = (KthReal)preTNode.attribute("WZ").as_double();
              preTrans[6] = (KthReal)preTNode.attribute("TH").as_double() * toRad;
            }

            limMin = (KthReal)(*it).child("Limits").attribute("Low").as_double();
            limMax = (KthReal)(*it).child("Limits").attribute("Hi").as_double();
            if( (*it).child("Description").attribute("rotational").as_bool() ){
              limMin *= toRad;
              limMax *= toRad;
            }

            addLink((*it).attribute("name").value(), dir + (*it).attribute("ivFile").value(),
                    (KthReal)(*it).child("DHPars").attribute("theta").as_double() * toRad,
                    (KthReal)(*it).child("DHPars").attribute("d").as_double(),
                    (KthReal)(*it).child("DHPars").attribute("a").as_double(),
                    (KthReal)(*it).child("DHPars").attribute("alpha").as_double() * toRad,
                    (*it).child("Description").attribute("rotational").as_bool(),
                    (*it).child("Description").attribute("movable").as_bool(),
                    limMin, limMax,
                    (KthReal)(*it).child("Weight").attribute("weight").as_double(),
                    (*it).child("Parent").attribute("name").value(), preTransP);

            if( i > 0 ){ //First link is ommited because it is the base.
              if( (*it).child("Weight") ) 
                _weights->setRnWeigh(i-1,(KthReal)(*it).child("Weight").attribute("weight").as_double());
              else
                _weights->setRnWeigh(i-1,(KthReal)1.0);
            }

            i++;

            preTransP = NULL ;

          }

          //  =====================
          //  Once the links were added, the controls can be configured
          //  Creating the mapping Matrix between controls and DOF parameters and initializing it.
          controlsName = "";
          mapMatrix = new KthReal*[6 + _currentConf.getRn().getDim()];
          offMatrix = new KthReal[6 + _currentConf.getRn().getDim()];

          numControls = doc.child("Robot").child("ControlSet").attribute("size").as_int();
          nTrunk = doc.child("Robot").child("ControlSet").attribute("nTrunk").as_int();
          numCoupledControls = doc.child("Robot").child("ControlSet").attribute("coupled").as_int();

          for(int i=0; i < 6 + _currentConf.getRn().getDim(); i++){
            mapMatrix[i] = new KthReal[numControls];
            offMatrix[i] = (KthReal)0.0;
            for(unsigned int j = 0; j < numControls; j++)
              mapMatrix[i][j] = (KthReal)0.0;
          }

          xml_node tmpNode = doc.child("Robot").child("ControlSet").child("Offset");
          xml_node::iterator it;
          string dofName = "";
          for(it = tmpNode.begin(); it != tmpNode.end(); ++it) {// PROCESSING ALL DOF FINDED
            dofName = (*it).attribute("name").value();
            if( dofName == "X"){
              se3Enabled = true;
              offMatrix[0] = (KthReal)(*it).attribute("value").as_double();
            }else if( dofName == "Y"){
              se3Enabled = true;
              offMatrix[1] = (KthReal)(*it).attribute("value").as_double();
            }else if( dofName == "Z"){
              se3Enabled = true;
              offMatrix[2] = (KthReal)(*it).attribute("value").as_double();
            }else if( dofName == "X1"){
              se3Enabled = true;
              offMatrix[3] = (KthReal)(*it).attribute("value").as_double();
            }else if( dofName == "X2"){
              se3Enabled = true;
              offMatrix[4] = (KthReal)(*it).attribute("value").as_double();
            }else if( dofName == "X3"){
              se3Enabled = true;
              offMatrix[5] = (KthReal)(*it).attribute("value").as_double();

            }else{    // It's not a SE3 control and could have any name.
                      //  Find the index orden into the links vector without the first static link.
              for(int ind = 0; ind < _currentConf.getRn().getDim(); ind++)
                if( dofName == links[ind+1]->getName()){
                  offMatrix[6 + ind ] = (KthReal)(*it).attribute("value").as_double();
                  break;
                }
            }
          }

          tmpNode = doc.child("Robot").child("ControlSet");
          string nodeType = "";
          int cont = 0;
          for(it = tmpNode.begin(); it != tmpNode.end(); ++it){  
            nodeType = it->name();
            if( nodeType == "Control" ){                       // Processing all controls found.
              xml_node::iterator itDOF;
              KthReal eigVal = (KthReal) (*it).attribute("eigValue").as_double();
              dofName = "";
              for(itDOF = (*it).begin(); itDOF != (*it).end(); ++itDOF) {// PROCESSING ALL DOF FINDED
                dofName = itDOF->attribute("name").value();
                if( dofName == "X"){
                  se3Enabled = true;
                  mapMatrix[0][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else if( dofName == "Y"){
                  se3Enabled = true;
                  mapMatrix[1][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else if( dofName == "Z"){
                  se3Enabled = true;
                  mapMatrix[2][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else if( dofName == "X1"){
                  se3Enabled = true;
                  mapMatrix[3][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else if( dofName == "X2"){
                  se3Enabled = true;
                  mapMatrix[4][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else if( dofName == "X3"){
                  se3Enabled = true;
                  mapMatrix[5][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                }else{      // It's not a SE3 control and could have any name.
                            //  Find the index orden into the links vector without the first static link.
                  for(int ind = 0; ind < _currentConf.getRn().getDim(); ind++)
                    if( dofName == links[ind+1]->getName()){
                      mapMatrix[6 + ind ][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                      break;
                    }
                }
              }// for(itDOF = dofItem.begin(); itDOF != dofItem.end(); ++itDOF) {// PROCESSING ALL DOF FINDED
              
              if(controlsName != "") controlsName.append("|");
                controlsName.append((*it).attribute("name").value());

              cont++;

            }// closing if(nodeType == "Control" )
          }//closing for(it = tmpNode.begin(); it != tmpNode.end(); ++it) for all ControlSet childs



        }else // the result of the file pasers is bad
          cout << "The robot file: " << robFile << " can not be read." << std::endl;


      }else{ //If robot is freeflying the robFile is a single Inventor file.
        robType = FREEFLY;
        name = "free";
        dhApproach = DHMODIFIED;
        addLink("", robFile, (KthReal)0.0, (KthReal)0.0, (KthReal)0.0, (KthReal)0.0,
                   false, false, (KthReal)0.0, (KthReal)0.0, (KthReal)1.0, "");

        //==============
        //  The freeflying robot has posible movements in all SE3 space and it hasn't controls.
        mapMatrix = new KthReal*[6];
        offMatrix = new KthReal[6];
        for(int i=0; i<6; i++){
          mapMatrix[i] = new KthReal[6];
          offMatrix[i] = (KthReal)0.5;
        }

        for(int i=0; i<6 ; i++)
          for(int j=0 ; j<6; j++)
            if(i == j)
              mapMatrix[i][j] = (KthReal)1.0;
            else
              mapMatrix[i][j] = (KthReal)0.0;
        controlsName = "X|Y|Z|X1|X2|X3";
        se3Enabled = true;
        numControls = 6;

        //======================
        //Now the associated weights
        _weights = new RobWeight(1);
        _weights->setSE3Weight(1., 1.);
        _weights->setRnWeigh(0,1.);

      } // closing if(robType != FREEFLY

      for(int i=0; i<7; i++)
        _spatialLimits[i][0] = _spatialLimits[i][1] = (KthReal) 0.0;

    }else{ // File does not exists.
      fin.close();
      cout << "The Robot file: " << robFile << "doesn't exist. Please confirm it." << endl;
      robType = FREEFLY;
      name = "free";
      dhApproach = DHMODIFIED;
    }

    armed = true;
  }

  
  bool Robot::attachObject(Obstacle* obs, string linkName ){
    try{
      attObj newObj;
      newObj.obs = obs;
      newObj.link = getLinkByName( linkName );
      mt::Transform tmpO;
      KthReal* pos = obs->getElement()->getPosition();
      tmpO.setTranslation( mt::Point3(pos[0], pos[1], pos[2] ) );
      pos = obs->getElement()->getOrientation();
      tmpO.setRotation( mt::Rotation( pos[0], pos[1], pos[2], pos[3] ) );
      newObj.trans = newObj.link->getTransformation()->inverse() * tmpO;
      _attachedObject.push_back( newObj );
      return true;
    }catch(...){
      return false;
    }
  }

  KthReal Robot::maxDHParameter(){
    KthReal maxim=0.;
    for(size_t i = 0; i < links.size(); ++i){
      maxim = getLink(i)->getA() > maxim ? getLink(i)->getA(): maxim;
      maxim = getLink(i)->getD() > maxim ? getLink(i)->getD(): maxim;   
    }
    return maxim;
  }

  void Robot::moveAttachedObj(){
    KthReal pos[3]={0.};
    KthReal ori[4]={0.};
    list<attObj>::iterator it = _attachedObject.begin();
    for( it = _attachedObject.begin(); it != _attachedObject.end(); ++it){
      mt::Transform tmp = *((*it).link->getTransformation());
      tmp *= (*it).trans;
      pos[0] = tmp.getTranslation().at(0);
      pos[1] = tmp.getTranslation().at(1);
      pos[2] = tmp.getTranslation().at(2);
      (*it).obs->getElement()->setPosition( pos );

      ori[0] = tmp.getRotation().at(0);
      ori[1] = tmp.getRotation().at(1);
      ori[2] = tmp.getRotation().at(2);
      ori[3] = tmp.getRotation().at(3);      
      (*it).obs->getElement()->setOrientation( ori );
    }
  }

  bool Robot::detachObject( string linkName ){
    bool found = false;
    list<attObj>::iterator it = _attachedObject.begin();
    for( it = _attachedObject.begin(); it != _attachedObject.end(); ++it){
      if((*it).toLink( linkName )){
        _attachedObject.erase(it);
        found = true;
      }
    }
    return found;
  }
  
  Link* Robot::getLinkByName( string linkName ){
    for(size_t i=0; i < links.size(); ++i){
      if(links[i]->getName() == linkName )
        return links[i];
    }
    return NULL;
  }

  string Robot::getDOFNames(){
    string tmp = "X|Y|Z|X1|X2|X3";
    for(unsigned int i = 1; i< links.size(); i++){
      tmp.append("|");
      tmp.append(links[i]->getName());
    }
    return tmp;
  }

  //! This method sets the new value for a particular dof of a particular 
  //! control
  bool Robot::setControlItem(string control, string dof, KthReal value){
    // First I will found the column index looking for "|" number before the control name.
    string::size_type pos = controlsName.find(control,0); 
    if(pos == string::npos) return false;
    int j=0;
    string::size_type trick=controlsName.find("|",0); 
    while(trick < pos){
      trick=controlsName.find("|",trick+1);
      j++;
    }
    for(unsigned int i = 1; i < links.size(); i++)
      if(links[i]->getName() == dof){ // Now I am finding the row index.
        mapMatrix[i][j] = value;
        return true;
      }
    return false;
  }
  
  //! This member function allows to change the values of every
  //! limit as well: x, y, z, wx, wy, wz, angle. There are respectively
  //! the position and orientation of all the robot. These values are
  //! in the world frame. 
  bool Robot::setLimits(int member, KthReal min, KthReal max){
	  if(member >= 0 && member < 7){
		  _spatialLimits[member][0] = min;
		  _spatialLimits[member][1] = max;
		  // It needs to recalculate the limits in home frame.
		  recalculateHomeLimits();
		  return true;
	  }
	  return false;
  }

  void Robot::recalculateHomeLimits(){
    mt::Point3 Pmin_W(_spatialLimits[0][0], _spatialLimits[1][0], _spatialLimits[2][0]);
    mt::Point3 Pmax_W(_spatialLimits[0][1], _spatialLimits[1][1], _spatialLimits[2][1]);
    mt::Point3 Pmin_H, Pmax_H;
    mt::Transform homeInv = _homeTrans.inverse();
    Pmin_H = homeInv*Pmin_W;
    Pmax_H = homeInv*Pmax_W;
    if( Pmin_H[0] == Pmax_H[0]){
      _homeLimits[0][0] = 0;                // Sets the Xmin in home frame
      _homeLimits[0][1] = 0;                // Sets the Xmax in home frame
    }else{
      _homeLimits[0][0] = Pmin_H[0];        // Sets the Xmin in home frame
      _homeLimits[0][1] = Pmax_H[0];        // Sets the Xmax in home frame
    }

    if( Pmin_H[1] == Pmax_H[1]){
      _homeLimits[1][0] = 0;                // Sets the Xmin in home frame
      _homeLimits[1][1] = 0;                // Sets the Xmax in home frame
    }else{
      _homeLimits[1][0] = Pmin_H[1];        // Sets the Ymin in home frame
      _homeLimits[1][1] = Pmax_H[1];        // Sets the Ymax in home frame
    }

    if( Pmin_H[2] == Pmax_H[2]){
      _homeLimits[2][0] = 0;                // Sets the Xmin in home frame
      _homeLimits[2][1] = 0;                // Sets the Xmax in home frame
    }else{
      _homeLimits[2][0] = Pmin_H[2];        // Sets the Zmin in home frame
      _homeLimits[2][1] = Pmax_H[2];        // Sets the Zmax in home frame
    }

  }

  bool Robot::setConstrainedKinematic(CONSTRAINEDKINEMATICS type){
    switch(type){
      case Kautham::UNCONSTRAINED:
        _constrainKin = NULL;
        break;
#if defined(KAUTHAM_USE_GUIBRO)
      case Kautham::BRONCHOSCOPY:
        _constrainKin = new ConsBronchoscopyKin(this);		  
        break;
#endif
      default:
        cout << "The Constrained Kinematic model has not be configured properly.\n" <<
          "See the ConsBronchoscopyKin of the Robot class to call the constructor. " << endl;
        _constrainKin = NULL;
        return false;
    }
    return true;
  }
  
  bool Robot::setConstrainedKinematicParameter(string name, KthReal value){
    if( _constrainKin != NULL)
      return _constrainKin->setParameter(name, value);
    return false;
  }

  RobConf& Robot::ConstrainedKinematics(vector<KthReal> &target){
    if(_constrainKin != NULL){
      //First i try to connect to the remote object
      //if this pointer is not null, the object has been instantiate correctly.
      _constrainKin->setTarget(target);
      if(_constrainKin->solve()){
		    return _constrainKin->getRobConf();
      }
    }
    return _currentConf;
  }

  bool Robot::setInverseKinematic(INVKINECLASSES type){
    switch(type){
      case Kautham::RR2D:
        _ikine = new IvKin2DRR(this);
        break;
      case Kautham::TX90:
        _ikine = new IvKinTx90(this);
        break;
      case Kautham::HAND:
        _ikine = new IvKinHand(this);
        break;
      case Kautham::TX90HAND:
        _ikine = new IvKinTxHand(this);
        break;
      default:
        cout << "The new Inverse Kinematic model have not been configured properly.\n" <<
          "See the setInverseKinematic of the Robot class to call the constructor. " << endl;
        _ikine = NULL;
        return false;
    }
    return true;
  }

  bool Robot::setInverseKinematicParameter(string name, KthReal value){
    if( _ikine != NULL)
      return _ikine->setParameter(name, value);
    return false;
  }

  bool Robot::Kinematics(RobConf *robq) {
    bool se = Kinematics(robq->getSE3());
    if(se && Kinematics(robq->getRn()))
      return true;
    else
      return false;
  }

  bool Robot::Kinematics(RobConf& robq) {
    bool se = Kinematics(robq.getSE3());
    if(se && Kinematics(robq.getRn()))
      return true;
    else
      return false;
  }

  bool Robot::Kinematics(SE3Conf& q) {
    vector<KthReal>& coor = q.getCoordinates();

    links[0]->getTransformation()->setTranslation(Point3(coor[0],coor[1], coor[2]));
    links[0]->getTransformation()->setRotation(Rotation(coor[3], coor[4], coor[5], coor[6]));
    links[0]->forceChange(NULL);

    _currentConf.setSE3(q);
    updateRobot();
    return true;
  }

  bool Robot::Kinematics(RnConf& q) {

	  /*
    if(q.getDim() == getNumJoints()){
      for(int i = 0; i < q.getDim(); i++)
        links[i+1]->setValue(q.getCoordinate(i));

      _currentConf.setRn(q);

      updateRobot();
      return true;
    }else
      return false;
	  */

	  if(q.getDim() > getNumJoints()) return false;

	  int n = getNumJoints();
	  if(q.getDim() < n){
		  RnConf q2(n);
		  int i;
		  std::vector<KthReal> coords(n); 
		  for(i = 0; i < q.getDim(); i++) coords[i]=q.getCoordinate(i);
		  for(; i < n; i++) coords[i]=0.0;
		  q2.setCoordinates(coords);

		  for(int i = 0; i < q2.getDim(); i++)
			  links[i+1]->setValue(q2.getCoordinate(i));
       
		  _currentConf.setRn(q2);
	  }
	  else{ //q.getDim() == getNumJoints()
		  for(int i = 0; i < q.getDim(); i++)
			  links[i+1]->setValue(q.getCoordinate(i));
       
		  _currentConf.setRn(q);
	  }

    updateRobot();
    return true;
  }



  bool Robot::Kinematics(Conf *q) {
    vector<KthReal>& coor = q->getCoordinates();

    //cout << "q.gettype "<<q->getType()<<endl;
    switch(q->getType()){
		  case SE3:
        links[0]->getTransformation()->setTranslation(Point3(coor[0],coor[1], coor[2])); 
        links[0]->getTransformation()->setRotation(Rotation(coor[3], coor[4], coor[5], coor[6]));
        links[0]->forceChange(NULL);
        _currentConf.setSE3(q->getCoordinates());
        //cout<<"current conf ("<< _currentConf.getSE3()->getCoordinate(0)<<", "<< _currentConf.getSE3()->getCoordinate(1)<<
        //", "<< _currentConf.getSE3()->getCoordinate(2)<<")"<<endl;
			  break;
		  case SE2:
        links[0]->getTransformation()->setTranslation(Point3(coor[0],coor[1], (KthReal)0.0)); 
        links[0]->getTransformation()->setRotation(Rotation((KthReal)0.0, (KthReal)0.0,
                                                            (KthReal)1.0, coor[2]));
        links[0]->forceChange(NULL);
        _currentConf.setSE3(q->getCoordinates());
        break;
		  case Rn:
		    if(q->getDim() == getNumJoints()){
				  for(int i=0; i<q->getDim(); i++)
					  links[i+1]->setValue(q->getCoordinate(i));

          _currentConf.setRn(q->getCoordinates());
			  }
        //cout<<"current conf Link[0] = "<< _currentConf.getRn().getCoordinate(0)<<endl;
			  break;
		  default:
			  return false;
	  }
     updateRobot();
    return true;
  }

  //!Call to inverseKinematics given the target defined as:
  //! a) the tcp transform
  //! b) a tcp transform and configuration parameters e.g. for the TX90: (l/r,ep/en,wp/wn)
  RobConf& Robot::InverseKinematics(vector<KthReal> &target){
    if(_ikine != NULL){
      //First i try to conect to the remote object
      //if this pointer is not null, the object has been instantiate correctly.
      _ikine->setTarget(target);
      if(_ikine->solve()){
        return _ikine->getRobConf();
      }
    }
    throw InvKinEx(0);
  }

  //!Call to inverseKinematics given:
  //! a) the target defined as the tcp transform
  //! b) a robot configuration used as a reference to copy its same configuration parameters e.g. for the TX90: (l/r,ep/en,wp/wn)
  RobConf& Robot::InverseKinematics(vector<KthReal> &target, vector<KthReal> masterconf, bool maintainSameWrist){
    if(_ikine != NULL){
      //First i try to conect to the remote object
      //if this pointer is not null, the object has been instantiate correctly.
      _ikine->setTarget(target, masterconf, maintainSameWrist);
      if(_ikine->solve()){
        return _ikine->getRobConf();
      }
    }
    throw InvKinEx(0);
  }

  bool Robot::autocollision(int t){
    //parameter t is used to only test the autocollision of the trunk part of a TREE robot
	  //it is set to 0 in robot.h 

    if(_hasChanged ){
      _autocoll = false;

      int maxLinksTested;
      //Restricted test to trunk in case of TREE robots
      if(robType==TREE && t==1)
        maxLinksTested = nTrunk;
      else
        maxLinksTested = links.size();

      for(int i=0; i< maxLinksTested; i++){
        //Collision detection with the Palm are avoided
        if(links[i]->getName() == "Palm" || links[i]->getName() == "Palm_izq" || links[i]->getName() == "Palm_der") {
          //cout <<"Palm detected - skipping collisions"<<endl;
          continue;
        }
        for(int j=i+2; j < maxLinksTested; j++){
          if(links[i]->getElement()->collideTo(links[j]->getElement())){
              //cout <<"...collision between links "<<i<<" and "<<j<<endl;
              //cout <<"...collision between links "<<links[i]->getName()<<" and "<<links[j]->getName()<<endl;
			  
                    _autocoll = true;
              return _autocoll;
            }
        }
      }
    }
    //cout<<"hasChanged = "<<_hasChanged<<" return autocollision "<<_autocoll<<endl;
    return _autocoll;
  }

  bool Robot::collisionCheck(Obstacle *obs) {
    if( autocollision() )
      return true;
    else{
      if(obs->getEnableCollisions()==false)
        return false; //transparent obstacle...

      //First probe the more moveable Link
      for(int i=links.size()-1; i >= 0; i--){
        if(links[i]->getElement()->collideTo(obs->getElement()))
          return true;
        }
      }
    return false;
  }

  //! This method verifies if this robot collides with the robot rob passed as a parameter.
  //! The method returns true when the two robots collide, otherwise returns false.
  bool Robot::collisionCheck(Robot *rob){
    if( _autocoll || rob->autocollision() ) return true;

    for(int i=0; i < links.size(); i++){
      for( int j = 0; j < rob->getNumLinks(); j++ ){
        if( links[i]->getElement()->collideTo(rob->getLink(j)->getElement()) )//{
            //cout <<"...collision between links "<<i<<" and "<<j<<endl;      
            return true;
          //}
      }
    }
    return false;
  }


  //! This methods returns the distance between the robot and the obstacle passed as parameter. 
  //! The distance returned is between the endEfector or the most distal link, but 
  //! if parameter min is true, the distace is the 
  KthReal Robot::distanceCheck(Obstacle *obs, bool min) {
    KthReal minDist = -1.0;
    KthReal tempDist = 0.0;
    if( autocollision() )
      return (KthReal)-1.0;
    else
      // First the most distal link
      minDist = links[links.size()-1]->getElement()->getDistanceTo(obs->getElement());
      if( min ){
        for(int i = links.size()-2; i >= 0 ; i--){
          tempDist = links[i]->getElement()->getDistanceTo(obs->getElement());
          if(minDist > tempDist)
            minDist = tempDist;
        }
      }
      return minDist;
  }

  KthReal Robot::distanceCheck(Robot *rob, bool min ){
    KthReal minDist = -1.0;
    KthReal tempDist = 0.0;

    if( !autocollision() )
      // First the most distal link
      minDist = links[links.size()-1]->getElement()->getDistanceTo(rob->getLink(0)->getElement());
      if( min ){
        for(int i = links.size() - 1; i >= 0 ; i--)
          for(size_t j = rob->getNumLinks() - 1; j >= 0; j--){
            tempDist = links[i]->getElement()->getDistanceTo(rob->getLink(j)->getElement());
            if(minDist > tempDist)
              minDist = tempDist;
        }
      }

    return minDist;
  }

  void Robot::setHomePos(Conf* qh){
    if( qh != NULL ){
      switch(qh->getType()){
        case SE3:
        case SE2:
          {
            _homeConf.setSE3(qh->getCoordinates());
            mt::Point3 tempTran(qh->getCoordinate(0),qh->getCoordinate(1),qh->getCoordinate(2));
            mt::Rotation tempRot(qh->getCoordinate(3),qh->getCoordinate(4),
                                 qh->getCoordinate(5),qh->getCoordinate(6));

            _homeTrans.setRotation(tempRot);
            _homeTrans.setTranslation(tempTran);

            recalculateHomeLimits();
          }
          break;
        case Rn:
          if(qh->getDim() == links.size() - 1){
          _homeConf.setRn(qh->getCoordinates());
        }
      }
      Kinematics(qh);

    }
  }

  void Robot::setInitPos(Conf* qi){
    if( qi != NULL ){
	    switch(qi->getType()){
		    case SE3:
		    case SE2:
				  _initConf.setSE3(qi->getCoordinates());
			    break;
		    case Rn:
			    if(qi->getDim() == links.size() - 1){
				  _initConf.setRn(qi->getCoordinates());
			  }
      }
    }
  }

  void Robot::setGoalPos(Conf* qg){
    if(qg != NULL){
	    switch(qg->getType()){
	      case SE3:
	      case SE2:
				  _goalConf.setSE3(qg->getCoordinates());
			    break;
		    case Rn:
			    if(qg->getDim() == links.size() - 1){
				  _goalConf.setRn(qg->getCoordinates());
			  }
      }
    }
  }

  bool	Robot::addLink(string name, string ivFile, KthReal theta, KthReal d,
                              KthReal a,KthReal alpha, bool rotational, bool movable,
                              KthReal low, KthReal hi, KthReal w, string parentName, KthReal preTrans[]){
    Link* temp = new Link(ivFile, this->getScale(), dhApproach, libs);
	  temp->setName(name);
    temp->setMovable(movable);
	  temp->setRotational(rotational);
	  temp->setDHPars(theta, d, a, alpha);
	  temp->setLimits(low, hi);
	  temp->setWeight(w);
    if(preTrans != NULL)
      temp->setPreTransform(preTrans[0],preTrans[1],preTrans[2], preTrans[3],
                            preTrans[4], preTrans[5], preTrans[6]);
    if(links.size() > 0 ){ 
      // There are finding the link by the name
      for(unsigned int i = links.size()-1; i >= 0 ; i--)
        if(parentName == links[i]->getName()){
          temp->setParent(links[i]);
          break;
        }
    }

	  temp->setArmed();
	  temp->setValue(0.0); //This is the home position
    links.push_back(temp);
	  return true;
  }

  
  //! This function return a pointer to the Link demanded.
  /*! If you pass a Link identification not valid it will return a null pointer.*/
  Link* Robot::getLink(unsigned int i) {
	  if(i<links.size())
		  return links[i];
	  else
		  return NULL;
  }

  void* Robot::getModel(){
    if(visModel == NULL){
      switch(libs){
        case IVPQP:
        case IVSOLID:
          SoSeparator* robot = new SoSeparator();
          robot->ref();
          for(unsigned int i =0; i < links.size(); i++)
            robot->addChild(((IVElement*)links[i]->getElement())->ivModel(true));
          
          // Now is adding the three dimensional proposed path for the last link
          _pathSeparator = new SoSeparator();
          _pathSeparator->ref();
          _pathSeparator->setName("Path");
          SoMaterial*  tmpMat = new SoMaterial();
          tmpMat->diffuseColor.setValue( 0., 0., 1.);
          _pathSeparator->addChild( tmpMat );
          SoVRMLExtrusion* tmpVRML = new SoVRMLExtrusion();
          //_pathSeparator->setName("Path");
          tmpVRML->solid.setValue(true);
          float diag = diagLimits()/100.;
          diag = diag < 2. ? 2. : diag;
          tmpVRML->scale.setValue( diag,diag );
          float vertex[13][2];
          vertex[0][0] = 0.1000;    vertex[0][1] = 0.;
          vertex[1][0] = 0.0866;    vertex[1][1] = 0.0500;
          vertex[2][0] = 0.0500;    vertex[2][1] = 0.0866;
          vertex[3][0] = 0.0000;    vertex[3][1] = 0.1000;
          vertex[4][0] = -0.0500;   vertex[4][1] = 0.0866;
          vertex[5][0] = -0.0866;   vertex[5][1] = 0.0500;
          vertex[6][0] = -0.1000;   vertex[6][1] = 0.0000;
          vertex[7][0] = -0.0866;   vertex[7][1] = -0.0500;
          vertex[8][0] = -0.0500;   vertex[8][1] = -0.0866;
          vertex[9][0] = -0.0000;   vertex[9][1] = -0.1000;
          vertex[10][0] = 0.0500;   vertex[10][1] = -0.0866;
          vertex[11][0] = 0.0866;   vertex[11][1] = -0.0500;
          vertex[12][0] = 0.1000;   vertex[12][1] = 0.;
          tmpVRML->crossSection.setValues(0,13,vertex);
          _graphicalPath = new SoMFVec3f();
          tmpVRML->spine.connectFrom(_graphicalPath);
          _pathSeparator->addChild(tmpVRML);

          robot->addChild(_pathSeparator);
          visModel = (void*)robot;
          break; 
      }    
    }
    return visModel;
  }

  float Robot::diagLimits(){
    float dia = 0.;
    for(int i = 0; i < 3; i++)
      dia += (_homeLimits[i][1] - _homeLimits[i][0] ) *
             (_homeLimits[i][1] - _homeLimits[i][0] );
    return sqrt(dia);
  }

  void* Robot::getModelFromColl(){
    SoSeparator* root = NULL;
    switch(libs){
      case IVPQP:
        root = new SoSeparator();
        for(unsigned int i =0; i < links.size(); i++)
          root->addChild(((IVPQPElement*)links[i]->getElement())->getIvFromPQPModel());
        return (void*)root;
        break;
      case IVSOLID:
        root = new SoSeparator();
        for(unsigned int i =0; i < links.size(); i++)
          root->addChild(((IVSOLIDElement*)links[i]->getElement())->getIvFromSOLIDModel());
        return (void*)root;
        break;
      default:
        return NULL;
    }
  }

    
  void Robot::control2Parameters(vector<KthReal> &control, vector<KthReal> &parameters){
    parameters.clear();
    if(robType == FREEFLY ){
      for(int i = 0; i < 6; i++)
        parameters.push_back((KthReal)0.0);
    }else{
      for(int i = 0; i < 6 + _currentConf.getRn().getDim(); i++)
        parameters.push_back((KthReal)0.0);
    }
    
    if(se3Enabled){
      for(int i =0; i < 6; i++){
        for(unsigned int j= 0; j < control.size(); j++)
          parameters[i] += mapMatrix[i][j] * (control[j]-0.5) ;
        parameters[i] += offMatrix[i];
      }
    }
    if( _currentConf.getRn().getDim() != 0 ){
      for(int i =0; i < _currentConf.getRn().getDim(); i++){
        for(unsigned int j= 0; j < control.size(); j++)//{
          parameters[i+6] += mapMatrix[i+6][j] * (control[j]-0.5);
          //cout << mapMatrix[i+6][j] << "\t" ;
        //}
        //cout << offMatrix[i+6];
        parameters[i+6] += offMatrix[i+6];
        //cout << endl;
      }
    }
  }
  
  void Robot::control2Pose(vector<KthReal> &values){
    vector<KthReal> vecTmp;
    _hasChanged = true;
    control2Parameters(values,vecTmp);
    parameter2Pose(vecTmp);
  }

  vector<KthReal> Robot::deNormalizeSE3(vector<KthReal> &values){
         std::vector<KthReal> coords(6);
    SE3Conf tmp;

    coords[0] = values[0]*(_homeLimits[0][1]-_homeLimits[0][0]) + _homeLimits[0][0];
    coords[1] = values[1]*(_homeLimits[1][1]-_homeLimits[1][0]) + _homeLimits[1][0];
    coords[2] = values[2]*(_homeLimits[2][1]-_homeLimits[2][0]) + _homeLimits[2][0];
    coords[3] = values[3];
    coords[4] = values[4];
    coords[5] = values[5];

    tmp.setCoordinates(coords); // It is the actual position but in the Home Frame

    mt::Point3 tempTran(tmp.getCoordinate(0),tmp.getCoordinate(1),tmp.getCoordinate(2));
    mt::Rotation tempRot(tmp.getCoordinate(3),tmp.getCoordinate(4),
                         tmp.getCoordinate(5),tmp.getCoordinate(6));

    mt::Transform in_home, in_world;
    in_home.setRotation(tempRot);
    in_home.setTranslation(tempTran);

    in_world = _homeTrans * in_home;      // Obtaining it in the world frame.
    tempTran = in_world.getTranslation();
    tempRot  = in_world.getRotation();

    coords.resize(7); // Resizing is needed to use quaternions
    coords[0] = tempTran[0];
    coords[1] = tempTran[1];
    coords[2] = tempTran[2];
    coords[3] = tempRot[0];
    coords[4] = tempRot[1];
    coords[5] = tempRot[2];
    coords[6] = tempRot[3];

    return coords;
  }

  //! This method maps between [0,1] parameter values to human readable values.
  //! The values vector must have the controls size.
  Conf& Robot::parameter2Conf(vector<KthReal> &values, CONFIGTYPE type){
    std::vector<KthReal> coords;
    switch(type){
    case SE3:
      //  First, denormalize the SE3 configuration from 6 values in the Home frame.
      coords = deNormalizeSE3(values);
      _currentConf.setSE3(coords);
      return _currentConf.getSE3();
      break;
    case Rn:
      if(_currentConf.getRn().getDim() == values.size()-6){
        coords.resize(_currentConf.getRn().getDim());
        for(unsigned int i = 1; i< links.size(); i++)
          coords[i-1] = ((Link*)links[i])->parameter2Value(values[i+5]);

        _currentConf.setRn(coords);
        return _currentConf.getRn();
      }
    }
    throw exception();
    
  }
 
  //! This member function makes the movements needed to achieve the pose.
  //! The vector values has the 6+Rn->getDim() size, in other words, the size
  //! of this vector is all posible movements of any robot (SE3 + links).
  void Robot::parameter2Pose(vector<KthReal> &values){
    if( armed /*&& numControls == values.size() */){
      _hasChanged = true;
      if(se3Enabled){
        // SE3 Denormalization in the wold frame
        vector<KthReal> coords = deNormalizeSE3(values);

        _currentConf.setSE3(coords);

        links[0]->getTransformation()->setTranslation(Point3(coords.at(0),coords.at(1), coords.at(2)));
        links[0]->getTransformation()->setRotation(Rotation(coords.at(3), coords.at(4),
                                                            coords.at(5), coords.at(6)));
        links[0]->forceChange(NULL);
        
      }
      if(_currentConf.getRn().getDim() != 0){
        // Rn denormalization
        vector<KthReal> coords(_currentConf.getRn().getDim());
        for(int i =0; i < _currentConf.getRn().getDim(); i++){
          links[i+1]->setParameter(values[6+i]);
          coords[i] = ((Link*)links[i+1])->getValue();
          //coords[i] = ((Link*)links[i+1])->parameter2Value(values[i+6]);
        }

        _currentConf.setRn(coords);
      }
      updateRobot();
    }
  }

  void Robot::updateRobot(){
    for(unsigned int i =0; i < links.size(); i++){
      if(links[i]->changed()){
       links[i]->calculatePnO();
       _hasChanged = true;
      }
    }

    if(_attachedObject.size() != 0 ) 
      moveAttachedObj();
  }

  bool Robot::setProposedSolution(vector<mt::Point3>& pathSE3){
    try{
      // Updating the graphical path if needed
      if( _graphicalPath != NULL )
        _graphicalPath->deleteValues( 0 );

      SbVec3f* temp = new SbVec3f[pathSE3.size()];
      vector<mt::Point3>::iterator it;
      unsigned int i = 0;
      for(it = pathSE3.begin(); it != pathSE3.end(); ++it){
        temp[i].setValue( (*it).at(0), (*it).at(1), (*it).at(2));
        ++i;
      }

      if( _graphicalPath != NULL )
        _graphicalPath->setValues(0, pathSE3.size(), temp);
      return true;
    }catch(...){
      return false;
    }
  }

  bool Robot::setProposedSolution(vector<RobConf*>& path){
    try{
      unsigned int i = 0;
      _proposedSolution.clear();
      for( i = 0; i < path.size(); i++)
        _proposedSolution.push_back(*(path.at(i)));

      // Updating the graphical path if needed
      if( _graphicalPath != NULL ) 
        _graphicalPath->deleteValues(0);

	  //if no need to draw path then return
	  if(_linkPathDrawn<0) return true;

	  //else fill graphicalPath
      SbVec3f* temp = new SbVec3f[path.size()];

      vector<RobConf>::iterator it;
      mt::Point3 pos;
      mt::Transform trans;
      i = 0;
      for(it = _proposedSolution.begin(); it != _proposedSolution.end(); ++it){
        Kinematics(*it);
        trans = getLinkTransform(_linkPathDrawn); //draws the path of link number linkPathDrawn
        //trans = getLastLinkTransform();
        pos = trans.getTranslation();
        temp[i].setValue( pos.at(0), pos.at(1), pos.at(2));
        ++i;
      }
      if( _graphicalPath != NULL )
        _graphicalPath->setValues(0, path.size(), temp);
      delete[] temp;
      return true;
    }catch(...){
      return false;
    }
  }

  bool Robot::cleanProposedSolution(){
    try{
      _proposedSolution.clear();
      if( _graphicalPath != NULL )
        _graphicalPath->deleteValues(0);
      return true;
    }catch(...){
      return false;
    }
  }

  bool Robot::setPathVisibility(bool visible){
    bool response=false;
    SoNode *sepgrid = NULL;
    try{
      if( visible ){
       //sepgrid = ((SoSeparator*)visModel)->getByName("Path");
       //if( sepgrid == NULL ) // It is OK, they is not attached to the root.
					((SoSeparator*)visModel)->addChild(_pathSeparator);
       
       response = true;
      }else{
        sepgrid = ((SoSeparator*)visModel)->getByName("Path");
        if( sepgrid != NULL ){
					((SoSeparator*)visModel)->removeChild(sepgrid);
          //sepgrid->unref();
        }

        response = false;
      }
    }catch(...){ }

    return response;
  }
}  	

